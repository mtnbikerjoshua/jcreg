?use_gpl3_license
use_gpl3_license()
vignette("roxygen2")
vignette("rd")
?pairs
mtcars
#'
#' This function uses pairs(data) to generate a scatterplot matrix with square
#' plots and solid points. Note that for best results you should set your plot
#' size to be square.
#'
#' @param data The coordinates of points given as numeric columns of a matrix
#' or data frame. See parameter `x` in `pairs()` for more detail.
#'
#' @examples
#' scores <- data.frame
point_matrix <- function(data) {
par(pty = "s", las = 1)
pairs(data, pch = 19, lower.panel = NULL)
}
point_matrix(mtcars)
vignette("ns")
vignette("namespace")
?update_collate
update_collate()
install.packages(c("backports", "bayesplot", "BH", "brio", "broom", "cli", "cpp11", "crayon", "crosstalk", "data.table", "DBI", "dbplyr", "desc", "DiceDesign", "diffobj", "dplyr", "DT", "fansi", "farver", "fastmap", "forcats", "furrr", "future", "ggplot2", "ggridges", "git2r", "hms", "htmltools", "htmlwidgets", "httpuv", "hunspell", "infer", "ipred", "IRdisplay", "isoband", "ISOcodes", "janitor", "jsonlite", "knitr", "lifecycle", "loo", "lubridate", "MatrixModels", "matrixStats", "mime", "mlr", "parallelly", "parsnip", "pbdZMQ", "pillar", "pkgbuild", "pkgload", "pROC", "promises", "quantreg", "rappdirs", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "repr", "reprex", "rio", "rmarkdown", "rsample", "shiny", "shinythemes", "SparseM", "SQUAREM", "StanHeaders", "stopwords", "testthat", "tibble", "tidyr", "tidytext", "tinytex", "tune", "usethis", "vctrs", "vip", "waldo", "withr", "xfun"))
?point_matrix
library(jcreg)
?corrplot
library(corrplot)  # For colored correlation matrix
library(corrplot)  # For colored correlation matrix
?corrplot
?cor
autoplot.lm
?autoplot.lm
?autoplot
library(ggfortify)  # Plot lm objects using ggplot instead of base R
?autoplot.lm
mtcars
lm(mpg ~ cyl, data = mtcars)
obj <- lm(mpg ~ cyl, data = mtcars)
class(obj)
#' Boxplot of residuals
#'
#' Uses ggplot to create a nicely formatted box plot of the residuals of a model
#'
#' @param model A linear regression model of class `stats::lm`
#'
#' @export
jcreg_boxplot <- function(model) {
residuals <- data.frame(residuals = resid(model))
ggplot(data = residuals, mapping = aes(y = residuals)) +
geom_boxplot() +
stat_summary(mapping = aes(x = 0),
fun = mean, geom = "point",
shape = 4, size = 2, color = "darkred") +
theme_classic() +
theme(aspect.ratio = 2,
axis.text.x = element_blank(),
axis.ticks.x = element_blank()) +
#  scale_y_continuous(limits = c(-20000, 30000), breaks = seq(-20000, 30000, 10000)) +
ylab("Residuals") +
xlab("")
}
jcreg_boxplot(lm(mtcars$mpg ~ mtcars$cyl))
jcreg_boxplot(lm(mpg ~ weight, data = mtcars))
mtcars
jcreg_boxplot(lm(mpg ~ disp, data = mtcars))
jcreg_hist(lm(mpg ~ disp, data = mtcars))
#' Histogram of Residuals
#'
#' Uses ggplot to create a nicely formatted histogram of the residuals of a
#' model overlaid with a normal curve.
#'
#' @param model A linear regression model of class `stats::lm`
#'
#' @export
jcreg_hist <- function(model) {
residuals <- data.frame(residuals = resid(model))
ggplot(data = residuals, mapping = aes(x = residuals)) +
geom_histogram(binwidth = sd(residuals$residuals / 4), mapping = aes(y = ..density..)) +
stat_function(fun = dnorm,
color = "blue",
args = list(mean = 0,
sd = sd(residuals$residuals)),
size = 1.2) +
xlab("Residuals") +
ylab("Density") +
theme_light()
}
jcreg_hist(lm(mpg ~ disp, data = mtcars))
#' Quantile - Quantile Plot
#'
#' Uses `autoplot` to plot a square, nicely-formatted Q-Q Plot of the residuals
#' of a linear model.
#'
#' @param model A linear regression model of class `stats::lm`
#'
#' @export
jcreg_qq <- function(model) {
autoplot(model, which = 2, ncol = 1) +
theme_bw() +
theme(aspect.ratio = 1)
}
jcreg_qq(lm(mpg ~ cyl, data = mtcars))
#' Cook's Distance Plot
#'
#' Plots the absolute value of cook's distance against observation number.
#'
#' @param model A linear regression model of class `stats::lm`
#' @param nLabels The number of potential influential points to label. Defaults
#' to 3. A value of 0 means do not label potential influential points.
#'
#' @export
jcreg_cooksd <- function(model, nLabels = 3) {
cooks_d <- cooks.distance(model)
top_cd <- as.numeric(names(sort(cooks_d, decreasing = TRUE)[1:nLabels]))
ggplot() +
geom_point(data = tibble(cooks_d),
mapping = aes(x = as.numeric(names(cooks_d)),
y = cooks_d)) +
geom_text(mapping = aes(x = top_cd,
y = cooks_d[top_cd] + max(cooks_d) / 40,
label = top_cd)) +
theme_bw() +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooks_d)),
color = "red", linetype = "dashed") +
theme(aspect.ratio = 1)
}
model <- lm(mpg ~ cyl, data = mtcars)
jcreg_cooksd(model)
#' Cook's Distance Plot
#'
#' Plots the absolute value of cook's distance against observation number.
#'
#' @param model A linear regression model of class `stats::lm`
#' @param nLabels The number of potential influential points to label. Defaults
#' to 3. A value of 0 means do not label potential influential points.
#'
#' @export
jcreg_cooksd <- function(model, nLabels = 3) {
cooks_d <- cooks.distance(model)
top_cd <- as.numeric(names(sort(cooks_d, decreasing = TRUE)[1:nLabels]))
ggplot() +
geom_point(data = data.frame(cooks_d),
mapping = aes(x = as.numeric(names(cooks_d)),
y = cooks_d)) +
geom_text(mapping = aes(x = top_cd,
y = cooks_d[top_cd] + max(cooks_d) / 40,
label = top_cd)) +
theme_bw() +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooks_d)),
color = "red", linetype = "dashed") +
theme(aspect.ratio = 1)
}
jcreg_cooksd(model)
cooks_d <- cooks.distance(model)
nLabels = 3
top_cd <- as.numeric(names(sort(cooks_d, decreasing = TRUE)[1:nLabels]))
ggplot() +
geom_point(data = tibble(cooks_d),
mapping = aes(x = as.numeric(names(cooks_d)),
y = cooks_d)) +
geom_text(mapping = aes(x = top_cd,
y = cooks_d[top_cd] + max(cooks_d) / 40,
label = top_cd)) +
theme_bw() +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooks_d)),
color = "red", linetype = "dashed") +
theme(aspect.ratio = 1)
library(tidyverse)
source('~/RProjects/jcreg/R/assumption_checking.R', echo=TRUE)
library(dplyr)
source('~/RProjects/jcreg/R/assumption_checking.R', echo=TRUE)
install.packages("dplyr")
source('~/RProjects/jcreg/R/assumption_checking.R', echo=TRUE)
jcreg_cooksd(model)
model <- lm(mpg ~ cyl, data = mtcars)
jcreg_cooksd(model)
# load packages here
library(tidyverse)
library(ggfortify)  # plot lm objects using ggplot instead of base R
library(car)  # needed for added-variable plots and dfbetas and dffits
library(corrplot)  # colored correlation matrix
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
#super <- read.csv("Supervisor.txt", header = TRUE, sep = " ")
#head(super)
(super <- read_table2("Supervisor.txt"))
point_matrix <- function(data) {
par(pty = "s", las = 1)
pairs(data, pch = 19, lower.panel = NULL)
}
point_matrix(super)
show_cor <- function(data) {
par(mfrow = c(1, 2))
corrplot(cor(data), method = "number", type = "upper", diag = F, tl.col = "#1f3366", cl.pos = "n")
title("Correlation Coefficients")
corrplot(cor(data), type = "upper", diag = F, tl.col = "#1f3366", cl.pos = "n")
title("Correlation Matrix")
}
show_cor(super)
super_lm <- lm(Rating ~ ., data = super)
summary(super_lm)
resid_vs_fitted <- function(model) {
autoplot(model, which = 1, ncol = 1) +
theme_minimal() +
theme(aspect.ratio = 1)
}
resid_vs_fitted(super_lm)
rpred_col <- function(data, residuals, predictor) {
ggplot(data = data,
mapping = aes(x = pull(data, predictor),
y = residuals)) +
geom_point() +
geom_smooth(se = FALSE, span = 0.95, n = 7, size = 0.5) +
geom_abline(slope = 0, intercept = 0, linetype = "dashed") +
theme_minimal() +
theme(aspect.ratio = 1) +
xlab(predictor) +
ylab("Residuals")
}
resid_vs_pred <- function(model) {
data <- model.frame(model)
predictors <- attr(model$terms, "term.labels")
plots <- lapply(predictors, rpred_col, data = data, residuals = resid(model))
plots["ncol"] <- ceiling(sqrt(length(plots)))
plots["top"] <- "Residuals vs Predictors"
do.call(grid.arrange, plots)
}
resid_vs_pred(super_lm)
added_variable_plots <- function(model) {
predictors <- attr(model$terms, "term.labels")
rows <- floor(sqrt(length(predictors)))
cols <- length(predictors) / rows
par(pty = "s", cex.lab = 2, cex.axis = 1.5)
avPlots(model, layout = c(rows, cols), pch = 19)
}
added_variable_plots(super_lm)
make_boxplot <- function(model) {
residuals <- data.frame(residuals = resid(model))
ggplot(data = residuals, mapping = aes(y = residuals)) +
geom_boxplot() +
stat_summary(mapping = aes(x = 0),
fun = mean, geom = "point",
shape = 4, size = 2, color = "darkred") +
theme_classic() +
theme(aspect.ratio = 2,
axis.text.x = element_blank(),
axis.ticks.x = element_blank()) +
#  scale_y_continuous(limits = c(-20000, 30000), breaks = seq(-20000, 30000, 10000)) +
ylab("Residuals") +
xlab("")
}
make_boxplot(super_lm)
make_hist <- function(model) {
residuals <- data.frame(residuals = resid(model))
ggplot(data = residuals, mapping = aes(x = residuals)) +
geom_histogram(binwidth = sd(residuals$residuals / 4), mapping = aes(y = ..density..)) +
stat_function(fun = dnorm,
color = "blue",
args = list(mean = 0,
sd = sd(residuals$residuals)),
size = 1.2) +
xlab("Residuals") +
ylab("Density") +
theme_light()
}
make_hist(super_lm)
QQPlot <- function(model) {
autoplot(model, which = 2, ncol = 1) +
theme_bw() +
theme(aspect.ratio = 1)
}
QQPlot(super_lm)
shapiro.test(super_lm$residuals)
cooksd_plot <- function(model, nLabels = 3) {
cooks_d <- cooks.distance(model)
top_cd <- as.numeric(names(sort(cooks_d, decreasing = TRUE)[1:nLabels]))
ggplot() +
geom_point(data = tibble(cooks_d),
mapping = aes(x = as.numeric(names(cooks_d)),
y = cooks_d)) +
geom_text(mapping = aes(x = top_cd,
y = cooks_d[top_cd] + max(cooks_d) / 40,
label = top_cd)) +
theme_bw() +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooks_d)),
color = "red", linetype = "dashed") +
theme(aspect.ratio = 1)
}
cooksd_plot(super_lm)
dfb_col <- function(df_betas, predictor, nLabels = 3) {
# Find which observations have the highest dfbetas
top_vals <- df_betas[predictor] %>%
arrange(desc(abs(eval(parse(text = predictor))))) %>%
.[1:nLabels,] %>%
pull(predictor)
top_ind <- which(pull(df_betas, predictor) %in% top_vals)
out <- ggplot() +
geom_point(data = df_betas,
mapping = aes(x = as.numeric(rownames(df_betas)),
y = abs(pull(df_betas, predictor)))) +
geom_text(mapping = aes(x = top_ind,
y = abs(pull(df_betas, predictor)[top_ind]) + 0.07,
label = top_ind)) +
theme_bw() +
theme(aspect.ratio = 1) +
ylab("Abs of DFBETAS") +
xlab("Observation Number") +
ggtitle(predictor)
if(length(dfbetas) <= 30) {
out <- out +
geom_hline(mapping = aes(yintercept = 1),
color = "red", linetype = "dashed")
}else {
out <- out +
geom_hline(mapping = aes(yintercept = 2 / sqrt(length(dfbetas))),
color = "red", linetype = "dashed")
}
return(out)
}
plot_dfbetas <- function(model, nLabels = 3) {
predictors <- attr(model$terms, "term.labels")
df_betas <- as_tibble(dfbetas(model)[, predictors])
plots <- lapply(predictors, dfb_col, df_betas = df_betas)
plots["ncol"] <- ceiling(sqrt(length(plots)))
do.call(grid.arrange, plots)
}
plot_dfbetas(super_lm)
plot_dffits <- function(model, nLabels = 3) {
df_fits <- dffits(model)
top_dff <- as.numeric(names(sort(abs(df_fits), decreasing = TRUE)[1:nLabels]))
df_fits_plot <- ggplot() +
geom_point(data = tibble(df_fits),
mapping = aes(x = as.numeric(names(df_fits)),
y = abs(df_fits))) +
geom_text(mapping = aes(x = top_dff,
y = abs(df_fits[top_dff]) + max(df_fits) / 40,
label = top_cd)) +
theme_bw() +
ylab("Absolute Value of DFFITS for Y") +
xlab("Observation Number") +
theme(aspect.ratio = 1)
if(length(df_fits) <= 30) {
df_fits_plot +
geom_hline(mapping = aes(yintercept =
2 * sqrt(length(model$coefficients) /
length(df_fits))),
color = "red", linetype = "dashed")
}else {
df_fits_plot +
geom_hline(mapping = aes(yintercept = 1),
color = "red", linetype = "dashed")
}
}
plot_dffits(super_lm)
cooksd_plot <- function(model, nLabels = 3) {
cooks_d <- cooks.distance(model)
top_cd <- as.numeric(names(sort(cooks_d, decreasing = TRUE)[1:nLabels]))
ggplot() +
geom_point(data = tibble(cooks_d),
mapping = aes(x = as.numeric(names(cooks_d)),
y = cooks_d)) +
geom_text(mapping = aes(x = top_cd,
y = cooks_d[top_cd] + max(cooks_d) / 40,
label = top_cd)) +
theme_bw() +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooks_d)),
color = "red", linetype = "dashed") +
theme(aspect.ratio = 1)
}
cooksd_plot(super_lm)
source('~/RProjects/jcreg/R/assumption_checking.R', echo=TRUE)
jcreg_cooksd(model)
jcreg_cooksd(super_lm)
model <- lm(mpg, cyl, data = mtcars)
lm(mpg, cyl, data = mtcars)
mtcars
lm(mpg ~ cyl, data = mtcars)
model <- lm(mpg ~ cyl, data = mtcars)
jcreg_cooksd(model)
library(jcreg)
cor_graphic(super)
jcreg_dfbetas(super_lm)
