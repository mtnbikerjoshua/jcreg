jcreg_dfbetas(lm(brozek ~ ., data = bodyfat))
#' @param model A linear regression model of class `stats::lm`.
#' @param nLabels The number of potential influential points to label. Defaults
#'   to 3. A value of 0 means do not label potential influential points.
#'
#' @return Returns a gridExtra object with class "gtable", "gTree", "grob", and
#'   "gDesc".
#'
#' @examples
#'
#' @export
jcreg_dfbetas <- function(model, nLabels = 3) {
predictors <- attr(model$terms, "term.labels")
df_betas <-  tibble::as_tibble(dfbetas(model))[, predictors]
plots <- lapply(predictors, dfb_col, df_betas = df_betas)
plots["ncol"] <- ceiling(sqrt(length(plots)))
do.call(gridExtra::grid.arrange, plots)
}
jcreg_dfbetas(lm(brozek ~ ., data = bodyfat))
jcreg_dfbetas(lm(brozek ~ ., data = bodyfat), nLabels = 0)
#' @param model A linear regression model of class `stats::lm`.
#' @param nLabels The number of potential influential points to label. Defaults
#'   to 3. A value of 0 means do not label potential influential points.
#'
#' @return Returns a gridExtra object with class "gtable", "gTree", "grob", and
#'   "gDesc".
#'
#' @examples
#'
#' @export
jcreg_dfbetas <- function(model, nLabels = 3) {
predictors <- attr(model$terms, "term.labels")
df_betas <-  tibble::as_tibble(dfbetas(model))[, predictors]
plots <- lapply(predictors, dfb_col, df_betas = df_betas, nLabels = nLabels)
plots["ncol"] <- ceiling(sqrt(length(plots)))
do.call(gridExtra::grid.arrange, plots)
}
jcreg_dfbetas(lm(brozek ~ ., data = bodyfat), nLabels = 0)
jcreg_cooksd(lm(brozek ~ ., data = bodyfat), nLabels = 0)
jcreg_dfbetas(lm(brozek ~ ., data = bodyfat), nLabels = 2)
jcreg_dffits(lm(brozek ~ ., data = bodyfat), nLabels = 2)
#' DFFITS Plot
#'
#' Plots the DFFITS against observation number.
#'
#' @param model A linear regression model of class `stats::lm`
#' @param nLabels The number of potential influential points to label. Defaults
#'   to 3. A value of 0 means do not label potential influential points. There
#'   is currently a bug where it always labels at least one point.
#'
#' @export
jcreg_dffits <- function(model, nLabels = 3) {
df_fits <- dffits(model)
top_dff <- as.numeric(names(sort(abs(df_fits), decreasing = TRUE)[1:nLabels]))
df_fits_plot <- ggplot2::ggplot() +
ggplot2::geom_point(data =tibble::tibble(df_fits),
mapping = ggplot2::aes(x = as.numeric(names(df_fits)),
y = abs(df_fits))) +
ggplot2::geom_text(mapping = ggplot2::aes(x = top_dff,
y = abs(df_fits[top_dff]) + max(df_fits) / 40,
label = top_dff)) +
ggplot2::theme_bw() +
ggplot2::ylab("Absolute Value of DFFITS for Y") +
ggplot2::xlab("Observation Number") +
ggplot2::theme(aspect.ratio = 1)
if(length(df_fits) <= 30) {
df_fits_plot +
ggplot2::geom_hline(mapping = ggplot2::aes(yintercept =
2 * sqrt(length(model$coefficients) /
length(df_fits))),
color = "red", linetype = "dashed")
}else {
df_fits_plot +
ggplot2::geom_hline(mapping = ggplot2::aes(yintercept = 1),
color = "red", linetype = "dashed")
}
}
jcreg_dffits(lm(brozek ~ ., data = bodyfat), nLabels = 2)
jcreg_dffits(lm(brozek ~ ., data = bodyfat), nLabels = 1)
#'   method and the output of each selection method. Printing this object will
#'   provide a table of the results. Also note that, for the shrinkage methods,
#'   there is a plot of loss against lambda saved in the method object eg.
#'   `my_var_selection$lasso$plot`. For a more detailed summary of the output you
#'   will soon be able to use `summary`. That feature is in development.
#'
#' @examples
#'
#'
#' @export
var_selection <- function(data, method = "all", metric = "BIC",
type.measure = "default", row = "method",
lambda = "lambda.1se") {
require(bestglm) # For step-wise selection
require(glmnet) # For shrinkage methods
if(method == "all") method <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
data <- as.data.frame(data) # In case `data` is a tibble, etc.
# `cv.glmnet` requires the predictors and response to be in separate matrices
predictors_matrix <- as.matrix(data[-length(data)])
response_matrix <- as.matrix(data[length(data)])
# A list of best models from each method
best_models <- vector(mode = "list", length = length(method))
names(best_models) <- method
if("best_subsets" %in% method) {
best_subsets <- bestglm(data, IC = metric, method = "exhaustive")
best_models$best_subsets <- best_subsets$BestModel
}
if("forward" %in% method) {
forward <- bestglm(data, IC = metric, method = "forward")
best_models$forward <- forward$BestModel
}
if("backward" %in% method) {
backward <- bestglm(data, IC = metric, method = "backward")
best_models$backward <- backward$BestModel
}
if("seqrep" %in% method) {
seqrep <- bestglm(data, IC = metric, method = "seqrep")
best_models$seqrep <- seqrep$BestModel
}
if("lasso" %in% method) {
lasso <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 1)
lasso$plot <- autoplot(lasso, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$lasso <- coef(lasso, s = lambda)
}
if("elastic" %in% method) {
elastic <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 0.5)
elastic$plot <- autoplot(elastic, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$elastic <- coef(elastic, s = lambda)
}
if(row == "method") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "method"` put the methods as rows and the variables as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(ncol = ncol(predictors_matrix),
nrow = length(best_models))
rownames(models_table) <- method_names[method_abbr %in% method]
colnames(models_table) <- colnames(predictors_matrix)
# Loop through the models and populate the matrix
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[i, ] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[i, ] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
else if(row == "var") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "var"` put the varaibles as rows and the methods as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(nrow = ncol(predictors_matrix),
ncol = length(best_models))
rownames(models_table) <- colnames(predictors_matrix)
colnames(models_table) <- method_names[method_abbr %in% method]
# Loop through the models and populate the matrix with the included variables
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[, i] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[, i] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
# The table is returned as a matrix of booleans, but will be printed with X's
#  in place of TRUE's
result <- list(table = models_table,
best_models = best_models,
best_subsets = best_subsets,
forward = forward,
backward = backward,
seqrep = seqrep,
lasso = lasso,
elastic = elastic,
metric = metric,
type.measure = type.measure)
class(result) <- "var_selection"
return(result)
}
var_selection(bodyfat)
#' Print `var_selection` Object
#'
#' Implements a print function for an object of type `var_selection`
#'
#' @param obj An object of class `var_selection`
#'
#' @export
print.var_selection <- function(obj) {
# Print the table of results using X's in place of TRUE's
print(ifelse(obj$table, "X", ""), quote = FALSE)
cat("\nStepwise Metric =", obj$metric, "\tShrinkage Measure =", obj$type.measure)
}
var_selection(bodyfat["age", "weight", "height", "neck", "chest", "abdom","brozek"])
var_selection(bodyfat[c("age", "weight", "height", "neck", "chest", "abdom","brozek")])
bodyfat_reordered <- bodyfat[c("age", "weight", "height", "neck",
"chest", "abdom","brozek")]
var_selection(bodyfat_reordered)
var_selection(bodyfat_reordered, method = c("best_subsets", "seqrep", "elastic"))
#'   will soon be able to use `summary`. That feature is in development.
#'
#' @examples
#' # Make sure to put the predictor variable last
#' bodyfat_reordered <- bodyfat[c("age", "weight", "height", "neck",
#'                                "chest", "abdom","brozek")]
#' var_selection(bodyfat_reordered)
#' var_selection(bodyfat_reordered, method = c("best_subsets", "seqrep", "elastic"))
#'
#' @export
var_selection <- function(data, method = "all", metric = "BIC",
type.measure = "default", row = "method",
lambda = "lambda.1se") {
require(bestglm) # For step-wise selection
require(glmnet) # For shrinkage methods
if(length(method) == 1 & method == "all") {
method <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
}
data <- as.data.frame(data) # In case `data` is a tibble, etc.
# `cv.glmnet` requires the predictors and response to be in separate matrices
predictors_matrix <- as.matrix(data[-length(data)])
response_matrix <- as.matrix(data[length(data)])
# A list of best models from each method
best_models <- vector(mode = "list", length = length(method))
names(best_models) <- method
if("best_subsets" %in% method) {
best_subsets <- bestglm(data, IC = metric, method = "exhaustive")
best_models$best_subsets <- best_subsets$BestModel
}
if("forward" %in% method) {
forward <- bestglm(data, IC = metric, method = "forward")
best_models$forward <- forward$BestModel
}
if("backward" %in% method) {
backward <- bestglm(data, IC = metric, method = "backward")
best_models$backward <- backward$BestModel
}
if("seqrep" %in% method) {
seqrep <- bestglm(data, IC = metric, method = "seqrep")
best_models$seqrep <- seqrep$BestModel
}
if("lasso" %in% method) {
lasso <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 1)
lasso$plot <- autoplot(lasso, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$lasso <- coef(lasso, s = lambda)
}
if("elastic" %in% method) {
elastic <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 0.5)
elastic$plot <- autoplot(elastic, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$elastic <- coef(elastic, s = lambda)
}
if(row == "method") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "method"` put the methods as rows and the variables as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(ncol = ncol(predictors_matrix),
nrow = length(best_models))
rownames(models_table) <- method_names[method_abbr %in% method]
colnames(models_table) <- colnames(predictors_matrix)
# Loop through the models and populate the matrix
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[i, ] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[i, ] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
else if(row == "var") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "var"` put the varaibles as rows and the methods as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(nrow = ncol(predictors_matrix),
ncol = length(best_models))
rownames(models_table) <- colnames(predictors_matrix)
colnames(models_table) <- method_names[method_abbr %in% method]
# Loop through the models and populate the matrix with the included variables
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[, i] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[, i] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
# The table is returned as a matrix of booleans, but will be printed with X's
#  in place of TRUE's
result <- list(table = models_table,
best_models = best_models,
best_subsets = best_subsets,
forward = forward,
backward = backward,
seqrep = seqrep,
lasso = lasso,
elastic = elastic,
metric = metric,
type.measure = type.measure)
class(result) <- "var_selection"
return(result)
}
bodyfat_reordered <- bodyfat[c("age", "weight", "height", "neck",
"chest", "abdom","brozek")]
var_selection(bodyfat_reordered)
var_selection(bodyfat_reordered, method = c("best_subsets", "seqrep", "elastic"))
#'   will soon be able to use `summary`. That feature is in development.
#'
#' @examples
#' # Make sure to put the predictor variable last
#' bodyfat_reordered <- bodyfat[c("age", "weight", "height", "neck",
#'                                "chest", "abdom","brozek")]
#' var_selection(bodyfat_reordered)
#' var_selection(bodyfat_reordered, method = c("best_subsets", "seqrep", "elastic"))
#'
#' @export
var_selection <- function(data, method = "all", metric = "BIC",
type.measure = "default", row = "method",
lambda = "lambda.1se") {
require(bestglm) # For step-wise selection
require(glmnet) # For shrinkage methods
if(method[1] == "all") {
method <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
}
data <- as.data.frame(data) # In case `data` is a tibble, etc.
# `cv.glmnet` requires the predictors and response to be in separate matrices
predictors_matrix <- as.matrix(data[-length(data)])
response_matrix <- as.matrix(data[length(data)])
# A list of best models from each method
best_models <- vector(mode = "list", length = length(method))
names(best_models) <- method
if("best_subsets" %in% method) {
best_subsets <- bestglm(data, IC = metric, method = "exhaustive")
best_models$best_subsets <- best_subsets$BestModel
}
if("forward" %in% method) {
forward <- bestglm(data, IC = metric, method = "forward")
best_models$forward <- forward$BestModel
}
if("backward" %in% method) {
backward <- bestglm(data, IC = metric, method = "backward")
best_models$backward <- backward$BestModel
}
if("seqrep" %in% method) {
seqrep <- bestglm(data, IC = metric, method = "seqrep")
best_models$seqrep <- seqrep$BestModel
}
if("lasso" %in% method) {
lasso <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 1)
lasso$plot <- autoplot(lasso, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$lasso <- coef(lasso, s = lambda)
}
if("elastic" %in% method) {
elastic <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 0.5)
elastic$plot <- autoplot(elastic, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$elastic <- coef(elastic, s = lambda)
}
if(row == "method") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "method"` put the methods as rows and the variables as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(ncol = ncol(predictors_matrix),
nrow = length(best_models))
rownames(models_table) <- method_names[method_abbr %in% method]
colnames(models_table) <- colnames(predictors_matrix)
# Loop through the models and populate the matrix
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[i, ] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[i, ] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
else if(row == "var") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "var"` put the varaibles as rows and the methods as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(nrow = ncol(predictors_matrix),
ncol = length(best_models))
rownames(models_table) <- colnames(predictors_matrix)
colnames(models_table) <- method_names[method_abbr %in% method]
# Loop through the models and populate the matrix with the included variables
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[, i] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[, i] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
# The table is returned as a matrix of booleans, but will be printed with X's
#  in place of TRUE's
result <- list(table = models_table,
best_models = best_models,
best_subsets = best_subsets,
forward = forward,
backward = backward,
seqrep = seqrep,
lasso = lasso,
elastic = elastic,
metric = metric,
type.measure = type.measure)
class(result) <- "var_selection"
return(result)
}
bodyfat_reordered <- bodyfat[c("age", "weight", "height", "neck",
"chest", "abdom","brozek")]
var_selection(bodyfat_reordered)
var_selection(bodyfat_reordered, method = c("best_subsets", "seqrep", "elastic"))
var_selection(bodyfat_reordered, row = "var")
library(jcreg)
library(jcreg)
head(bodyfat)
jcreg_boxplot(bodyfat)
jcreg_boxplot(lm(brozek ~ ., data = bodyfat))
library(jcreg)
jcreg_cooksd(lm(brozek ~ ., data = bodyfat))
var_selection(bodyfat)
?var_selection
bodyfat_reordered <- bodyfat[c("age", "weight", "height", "neck",
"chest", "abdom","brozek")]
var_selection(bodyfat_reordered)
library(jcreg)
var_selection(bodyfat_reordered)
