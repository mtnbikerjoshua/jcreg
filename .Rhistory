theme_bw() +
theme(aspect.ratio = 1)
best_models$lasso <- coef(lasso, s = "lambda.1se")
}
if("elastic" %in% method) {
elastic <- cv.glmnet(x = predictors_matrix, y = response_matrix,
type.measure = type.measure, alpha = 0.5)
elastic$plot <- autoplot(elastic, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
best_models$elastic <- coef(elastic, s = "lambda.1se")
}
if(row == "method") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "method"` put the methods as rows and the variables as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(ncol = ncol(predictors_matrix),
nrow = length(best_models))
rownames(models_table) <- method_names[method_abbr %in% method]
colnames(models_table) <- colnames(predictors_matrix)
# Loop through the models and populate the matrix
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[i, ] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[i, ] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
else if(row == "var") {
# Create a matrix to be filled with booleans indicating which variables are
#  included in the best model found by each selection method
# For `row = "var"` put the varaibles as rows and the methods as columns
method_names <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
method_abbr <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
models_table <- matrix(nrow = ncol(predictors_matrix),
ncol = length(best_models))
rownames(models_table) <- colnames(predictors_matrix)
colnames(models_table) <- method_names[method_abbr %in% method]
# Loop through the models and populate the matrix with the included variables
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[, i] <-
colnames(predictors_matrix) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model as an lm object
else {
models_table[, i] <-
colnames(predictors_matrix) %in%
names(model$coefficients)
}
}
}
# The table is returned as a matrix of booleans, but will be printed with X's
#  in place of TRUE's
result <- list(table = models_table,
best_models = best_models,
best_subsets = best_subsets,
forward = forward,
backward = backward,
seqrep = seqrep,
lasso = lasso,
elastic = elastic,
metric = metric,
type.measure = type.measure)
class(result) <- "var_selection"
return(result)
}
print.var_selection <- function(obj) {
# Print the table of results using X's in place of TRUE's
print(ifelse(obj$table, "X", ""), quote = FALSE)
cat("\nstepwise metric =", obj$metric, "\tShrinkage Measure =", obj$type.measure)
}
var_selection(bodyfat)
print.var_selection <- function(obj) {
# Print the table of results using X's in place of TRUE's
print(ifelse(obj$table, "X", ""), quote = FALSE)
cat("\nStepwise Metric =", obj$metric, "\tShrinkage Measure =", obj$type.measure)
}
?data.frame
?as.data.frame
?bestglm
?cv.glmnet
best_models$lasso <- coef(lasso, s = "lambda.1se")
coef(lasso, s = "lambda.1se")
best_models$lasso <- coef(lasso, s = "lambda.min")
oef(lasso, s = "lambda.min")
coef(lasso, s = "lambda.min")
library(devtools)
install.packages("devtools")
install.packages("roxygen2")
library(devtools)
library(roxygen2)
vignette("roxygen2")
library(jcreg)
library(jcreg)
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
library(tidyverse)
library(corrplot)  # colored correlation matrix
library(ggfortify)  # plot glmnet objects using ggplot instead of base R
library(car)  # needed for VIFs
library(bestglm)  # for stepwise methods
library(glmnet)  # for ridge, lasso, and elastic net
set.seed(6865)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
library(tidyverse)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
library(tidyverse)
library(corrplot)  # colored correlation matrix
library(ggfortify)  # plot glmnet objects using ggplot instead of base R
library(car)  # needed for VIFs
library(bestglm)  # for stepwise methods
library(glmnet)  # for ridge, lasso, and elastic net
set.seed(6865)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
bodyfat <- bodyfat_orig %>%
slice(-39)
library(jcreg)
library(jcreg)
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
library(tidyverse)
library(corrplot)  # colored correlation matrix
library(ggfortify)  # plot glmnet objects using ggplot instead of base R
library(car)  # needed for VIFs
library(bestglm)  # for stepwise methods
library(glmnet)  # for ridge, lasso, and elastic net
set.seed(6865)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
bodyfat <- bodyfat_orig %>%
slice(-39)
var_selection(bodyfat)
if(TRUE) var72 <- 5
var72
library(jcreg)
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
library(tidyverse)
library(corrplot)  # colored correlation matrix
library(ggfortify)  # plot glmnet objects using ggplot instead of base R
library(car)  # needed for VIFs
library(bestglm)  # for stepwise methods
library(glmnet)  # for ridge, lasso, and elastic net
set.seed(6865)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
bodyfat <- bodyfat_orig %>%
slice(-39)
var_selection(bodyfat)
library(jcreg)
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
library(tidyverse)
library(corrplot)  # colored correlation matrix
library(ggfortify)  # plot glmnet objects using ggplot instead of base R
library(car)  # needed for VIFs
library(bestglm)  # for stepwise methods
library(glmnet)  # for ridge, lasso, and elastic net
set.seed(6865)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
bodyfat <- bodyfat_orig %>%
slice(-39)
var_selection(bodyfat)
data <- bodyfat
method = "all"
metric = "BIC"
type.measure = "default"
row = "method"
lambda = "lambda.1se"
require(bestglm) # For step-wise selection
require(glmnet) # For shrinkage methods
if(method == "all") method <- c("best_subsets", "forward", "backward",
"seqrep", "lasso", "elastic")
data <- as.data.frame(data) # In case `data` is a tibble, etc.
# `cv.glmnet` requires the predictors and response to be in separate matrices
predictors_matrix <- as.matrix(data[-length(data)])
response_matrix <- as.matrix(data[length(data)])
# A list of best models from each method
best_models <- vector(mode = "list", length = length(method))
names(best_models) <- method
if("best_subsets" %in% method) {
best_subsets <- bestglm(data, IC = metric, method = "exhaustive")
best_models$best_subsets <- best_subsets$BestModel
}
if("forward" %in% method) {
forward <- bestglm(data, IC = metric, method = "forward")
best_models$forward <- forward$BestModel
}
forward <- bestglm(data, IC = metric, method = "forward")
bestglm(data, IC = metric, method = "exhaustive")
bestglm(data, IC = metric, method = "forward")
metric <- "AIC"
bestglm(data, IC = metric, method = "forward")
bestglm(data, IC = metric, method = "forward")
bodyfat
library(gridExtra)  # NEW PACKAGE for putting multiple ggplots in one plot
library(tidyverse)
library(corrplot)  # colored correlation matrix
library(ggfortify)  # plot glmnet objects using ggplot instead of base R
library(car)  # needed for VIFs
library(bestglm)  # for stepwise methods
library(glmnet)  # for ridge, lasso, and elastic net
set.seed(6865)
bodyfat_orig <- read.csv("bodyfat.txt", sep = " ", row.names = 1)
(bodyfat_orig <- tibble(bodyfat_orig))
summary(bodyfat_orig)
bodyfat <- bodyfat_orig %>%
slice(-39)
bodyfat <- bodyfat %>%
select(age, weight, height, neck, chest, abdom, brozek)
bodyfat_df <- data.frame(bodyfat)
best_subsets <- bestglm(bodyfat_df, IC = "AIC", method = "exhaustive")
best_subsets$BestModels
summary(best_subsets$BestModel)
# Save the best models
best_models <- list()
best_models$best_subsets <- best_subsets$BestModel
forward <- bestglm(bodyfat_df, IC = "AIC", method = "forward")
forward$BestModels
summary(forward$BestModel)
best_models$forward <- forward$BestModel
backward <- bestglm(bodyfat_df, IC = "AIC", method = "backward")
backward$BestModels
summary(backward$BestModel)
best_models$backward <- backward$BestModel
seqrep <- bestglm(bodyfat_df, IC = "AIC", method = "seqrep")
seqrep$BestModels
summary(seqrep$BestModel)
best_models$seqrep <- seqrep$BestModel
bodyfat_predictors <- bodyfat %>%
select(-brozek) %>%
as.matrix()
bodyfat_response <- bodyfat %>%
select(brozek) %>%
as.matrix()
# Use cross validation to pick the best penalty parameter based on MSE
lasso <- cv.glmnet(x = bodyfat_predictors, y = bodyfat_response,
type.measure = "mse", alpha = 1)
# Plot log(lambda) against MSE
autoplot(lasso, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
# Pick the lambda value within 1 SE of the minimum MSE
lasso$lambda.1se
# Print the selected coefficients using the 1 SE lambda
(best_models$lasso <- coef(lasso, s = "lambda.1se"))
# Use cross validation to pick the best penalty parameter based on MSE
elastic <- cv.glmnet(x = bodyfat_predictors, y = bodyfat_response,
type.measure = "mse", alpha = 0.5)
# Plot log(lambda) against MSE
autoplot(elastic, label = FALSE) +
theme_bw() +
theme(aspect.ratio = 1)
# Pick the lambda value within 1 SE of the minimum MSE
elastic$lambda.1se
# Print the selected coefficients using the 1 SE lambda
(best_models$elastic <- coef(elastic, s = "lambda.1se"))
# Create a matrix to be filled with booleans
models_table <- matrix(ncol = ncol(bodyfat_predictors),
nrow = length(best_models))
rownames(models_table) <- c("Best Subset", "Forward", "Backward",
"Sequential Rep.", "LASSO", "Elastic Net")
colnames(models_table) <- colnames(bodyfat_predictors)
# Loop through the models and populate the matrix with the included variables
for(i in 1:length(best_models)) {
model <- best_models[[i]]
# For the shrinkage methods we saved a matrix of the coefficients
if("dgCMatrix" %in% class(model)) {
models_table[i, ] <-
colnames(bodyfat_predictors) %in%
rownames(model)[attr(model, "i") + 1] # +1 for 1 based indexing
}
# For the other methods we saved the best model
else {
models_table[i, ] <-
colnames(bodyfat_predictors) %in%
names(model$coefficients)
}
}
# Print the matrix using X's in place of TRUE's
noquote(ifelse(models_table, "X", ""))
bodyfat_lm <- lm(brozek ~ height + neck + abdom, data = bodyfat)
summary(bodyfat_lm)
bodyfat_select <- bodyfat %>%
select(brozek, abdom, height, neck)
# Scatterplot matrix
point_matrix <- function(data) {
par(pty = "s", las = 1)
pairs(data, pch = 19, lower.panel = NULL)
}
point_matrix(bodyfat_select)
# residual vs. predictor plots
rpred_col <- function(data, residuals, predictor) {
ggplot(data = data,
mapping = aes(x = pull(data, predictor),
y = residuals)) +
geom_point() +
geom_smooth(se = FALSE, span = 0.95, n = 7, size = 0.5) +
geom_abline(slope = 0, intercept = 0, linetype = "dashed") +
theme_minimal() +
theme(aspect.ratio = 1) +
xlab(predictor) +
ylab("Residuals")
}
resid_vs_pred <- function(model) {
data <- model.frame(model)
predictors <- attr(model$terms, "term.labels")
plots <- lapply(predictors, rpred_col, data = data, residuals = resid(model))
plots["ncol"] <- ceiling(sqrt(length(plots)))
plots["top"] <- "Residuals vs Predictors"
do.call(grid.arrange, plots)
}
resid_vs_pred(bodyfat_lm)
# partial regression plots
added_variable_plots <- function(model) {
predictors <- attr(model$terms, "term.labels")
rows <- floor(sqrt(length(predictors)))
cols <- length(predictors) / rows
par(pty = "s", cex.lab = 1.5, cex.axis = 1.5)
avPlots(model, layout = c(rows, cols), pch = 19)
}
added_variable_plots(bodyfat_lm)
# residuals vs fitted values
resid_vs_fitted <- function(model) {
autoplot(model, which = 1, ncol = 1) +
theme_minimal() +
theme(aspect.ratio = 1)
}
resid_vs_fitted(bodyfat_lm)
# Boxplot
make_boxplot <- function(model) {
residuals <- data.frame(residuals = resid(model))
ggplot(data = residuals, mapping = aes(y = residuals)) +
geom_boxplot() +
stat_summary(mapping = aes(x = 0),
fun = mean, geom = "point",
shape = 4, size = 2, color = "darkred") +
theme_classic() +
theme(aspect.ratio = 2,
axis.text.x = element_blank(),
axis.ticks.x = element_blank()) +
#  scale_y_continuous(limits = c(-20000, 30000), breaks = seq(-20000, 30000, 10000)) +
ylab("Residuals") +
xlab("")
}
make_boxplot(bodyfat_lm)
# Histogram
make_hist <- function(model) {
residuals <- data.frame(residuals = resid(model))
ggplot(data = residuals, mapping = aes(x = residuals)) +
geom_histogram(binwidth = sd(residuals$residuals / 4), mapping = aes(y = ..density..)) +
stat_function(fun = dnorm,
color = "blue",
args = list(mean = 0,
sd = sd(residuals$residuals)),
size = 1.2) +
xlab("Residuals") +
ylab("Density") +
theme_light()
}
make_hist(bodyfat_lm)
# Q-Q
QQPlot <- function(model) {
autoplot(model, which = 2, ncol = 1) +
theme_bw() +
theme(aspect.ratio = 1)
}
QQPlot(bodyfat_lm)
# Shapiro-Wilk
shapiro.test(bodyfat_lm$residuals)
resid_vs_fitted(bodyfat_lm)
# Cook's Distance
cooksd_plot <- function(model, nLabels = 3) {
cooks_d <- cooks.distance(model)
top_cd <- as.numeric(names(sort(cooks_d, decreasing = TRUE)[1:nLabels]))
ggplot() +
geom_point(data = tibble(cooks_d),
mapping = aes(x = as.numeric(names(cooks_d)),
y = cooks_d)) +
geom_text(mapping = aes(x = top_cd,
y = cooks_d[top_cd] + max(cooks_d) / 40,
label = top_cd)) +
theme_bw() +
ylab("Cook's Distance") +
xlab("Observation Number") +
geom_hline(mapping = aes(yintercept = 4 / length(cooks_d)),
color = "red", linetype = "dashed") +
theme(aspect.ratio = 1)
}
cooksd_plot(bodyfat_lm)
# DFBETAS
dfb_col <- function(df_betas, predictor, nLabels = 3) {
# Find which observations have the highest dfbetas
top_vals <- df_betas[predictor] %>%
arrange(desc(abs(eval(parse(text = predictor))))) %>%
.[1:nLabels,] %>%
pull(predictor)
top_ind <- which(pull(df_betas, predictor) %in% top_vals)
out <- ggplot() +
geom_point(data = df_betas,
mapping = aes(x = as.numeric(rownames(df_betas)),
y = abs(pull(df_betas, predictor)))) +
geom_text(mapping = aes(x = top_ind,
y = abs(pull(df_betas, predictor)[top_ind]) + 0.07,
label = top_ind)) +
theme_bw() +
theme(aspect.ratio = 1) +
ylab("Abs of DFBETAS") +
xlab("Observation Number") +
ggtitle(predictor)
if(length(dfbetas) <= 30) {
out <- out +
geom_hline(mapping = aes(yintercept = 1),
color = "red", linetype = "dashed")
}else {
out <- out +
geom_hline(mapping = aes(yintercept = 2 / sqrt(length(dfbetas))),
color = "red", linetype = "dashed")
}
return(out)
}
plot_dfbetas <- function(model, nLabels = 3) {
predictors <- attr(model$terms, "term.labels")
df_betas <- as_tibble(dfbetas(model)[, predictors])
plots <- lapply(predictors, dfb_col, df_betas = df_betas)
plots["ncol"] <- ceiling(sqrt(length(plots)))
do.call(grid.arrange, plots)
}
plot_dfbetas(bodyfat_lm)
# DFFITS
plot_dffits <- function(model, nLabels = 3) {
df_fits <- dffits(model)
top_dff <- as.numeric(names(sort(abs(df_fits), decreasing = TRUE)[1:nLabels]))
df_fits_plot <- ggplot() +
geom_point(data = tibble(df_fits),
mapping = aes(x = as.numeric(names(df_fits)),
y = abs(df_fits))) +
geom_text(mapping = aes(x = top_dff,
y = abs(df_fits[top_dff]) + 0.05,
label = top_dff)) +
theme_bw() +
ylab("Absolute Value of DFFITS for Y") +
xlab("Observation Number") +
theme(aspect.ratio = 1)
if(length(df_fits) <= 30) {
df_fits_plot +
geom_hline(mapping = aes(yintercept =
2 * sqrt(length(model$coefficients) /
length(df_fits))),
color = "red", linetype = "dashed")
}else {
df_fits_plot +
geom_hline(mapping = aes(yintercept = 1),
color = "red", linetype = "dashed")
}
}
plot_dffits(bodyfat_lm)
# Variance Inflation Factors
(vifs <- vif(bodyfat_lm))
mean(vifs)
# Correlation
show_cor <- function(data) {
par(mfrow = c(1, 2))
corrplot(cor(data), method = "number", type = "upper", diag = F, tl.col = "#1f3366", cl.pos = "n")
title("Correlation Coefficients")
corrplot(cor(data), type = "upper", diag = F, tl.col = "#1f3366", cl.pos = "n")
title("Correlation Matrix")
}
show_cor(bodyfat_select)
# Scatterplot matrix
point_matrix(bodyfat_select)
bestglm(data, IC = metric, method = "forward")
metric
forward
bodyfat <- bodyfat %>%
select(age, weight, height, neck, chest, abdom, brozek)
bestglm(data, IC = metric, method = "forward")
data <- bodyfat
var_selection(bodyfat)
14040.2-1830.7
1113.9*24-25094.7-(201.7*24-7515.2)
1113.9*24-25094.7-(201.7*24-7516.2)
